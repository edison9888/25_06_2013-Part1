PLNDR iPhone App
=============

Testing Flags
-------

The following flags are in Constants.h. Use them to quickly switch to testing:

* kUseStaginUrls -- 1  		//(YES) to switch to staging URLs. 0 (NO) for production. USE THE BINARY. We need it for a preprocessor flag.
* define kUseDebugGAN -- NO      // YES for our local GAN account. No for production.
* define kTestPurchase -- YES    // YES for testing purchase, NO for production. If this flag is set to YES, credit cards will be charged and then immediately refunded during purchase. If it's set to no, you will be charged.

Third Party Libraries
-------

* Google Analytics -- for tracking
* enormego-EGOTableViewPullRefresh -- for "Pull to Refresh" functionality
* facebook-ios-sdk -- Facebook
* OHAttributedLabel -- For strings with links, underlines, mixed colours and fonts, etc
* iCarousel -- A simple carousel library. We're using it for the scroll wheel on the home page
* SBJSON -- a JSON parser

Sending Client Builds
-------

We have sent client builds using Beta Builder. You can find it linked on the project wiki.

To use Beta Builder:

* Open the project file in xCode
* Build (for OSX, not iOS). Beta Builder should launch.
* Chose an IPA to upload. It should automatically fill in Bundle Identifier, Bundle Version, and App Name.
* Chose a "Full Web Deployment Path". This is the url at which you will download the app. (Gotcha: make sure the URL ends in '/': it should look something like 'http://foo.com/myapp/week1/'). We used the asset server. The path must match the path of the location where you will upload the build.
* Hit "Generate Deployment Files." Pick a directory (Gotcha: not the directory containing your IPA. It doesn't like that - it will delete your IPA and spit out an error) to create files in. Do it.
* Copy everything in the directory above to your server.
* Try hitting the URL - you should see a nicely formatted website showing information about your build, and a link.

Note: DO NOT use Beta Builder for beta or QA builds, without first carefully investigating how Beta Builder handles an enterprise provisioning profile. I suspect it's not protected.

The Code
=============

Automated Model Generation
-------

We tried out Elliot's Automated Model Generation on this project, with great success.

The idea behind automated model generation is that if something small in the model changes, you only have to make an update reflecting that change in one place.

Using XL-XAMG:
* To create or modify a model, open model.json and define the object, using the existing objects as examples of good format.
* Download [XL-XAMG](https://github.com/xtremelabs/xl-XAMG) (Internal Xtreme Labs tool) and install it. FOLLOW THE README. Note that you must use python3
* In terminal, in the xl-XAMG folder, run this: "python3 main.py generate ~/workspace/karmaloop-plndrapp-ios/Utility/xl-amg/config.py", changing the directory so it locates config.py if necessary. Additionally, you may need to update self.model_path, self.output_path and self.template_directory in config.py to reflect your machine.
* Check in the project's AutogeneratedModels folder. You should see the new models. They will be named "\<YourName\>Object". FYI, these files were built based on the template files, which are also modifiable: template_objc_header and template_objc_message
* Create the model file that you will actually use in the project: in ModifiedModels, create an object "\<YourName\>" which extends "\<YourName\>Object". This is the object you should instantiate to use your model. In this file, you can create additional properties. If you need to do any post processing on the data being read from the API (ex - convert an ISO string formatted date to an NSDate), implement (void) postProcessData. Be aware that if you add properties, you will also need to implement encodeWithCoder, initWithCoder, and copyWithZone. There are lots of examples in AutogeneratedModels/ModifiedModels
* To instantiate the object from API data, get the data as an NSDictionary (this is handled automatically as part of our network handling - look for "initFromDictionary:" in ModelContext for lots of examples), and call initFromDictionary.

That might sound like a lot of overhead to create a model, but it's only overhead the first couple of times, when you need to install XL-XAMG, set up your configuration, and understand how it all works. After that, this is a great time saver. As an example, say a new key was added to the Product API, and as a result, we needed to add a property "newKey" to the Product object. Here would be the steps:

* Go into model.json and add "newKey" to the Product object definition
* Regenerate the model by running "python3 main.py generate ~/workspace/karmaloop-plndrapp-ios/Utility/xl-amg/config.py"

You can now use the new property in the code - parsing was handled automatically by the base class for the autogenerated models - JSONBase.

Modifying model.json: properties in your object are defined as follows:
* type: possible types are string, number (used for number and bool), \<class\> (as defined by another object in model.json), or \<type\>\[\] - an array
* key: the key in the API
* name: the property name. Often the same as key, but you can name it differently if you want


Model Subscription (Handling Network Requests)
-------

We used Brian Croom's Model Subscription framework for networking. The idea is that controllers shouldn't need to know anything about network requests: they should be able to ask for data, and respond to events such as "Data is available", "Data is loading", and "Data is unavailable"

The following is an explanation of how the HomeViewController get's sales. Consider this documentation-by-example.

From the HomeViewController:

1. When the controller wants to know what sales are available, it instantiates a SalesSubscription.
2. When the state of sale data changes (possible states for this data are pending, available, unknown/unavailable), the HomeViewController get's notified through SubscriptionUpdatedState:(ModelSubscription). Here, it checks the state of the subscription and responds appropriately. So first it get's a notification that data is pending, and it shows a loading view. Then it get's a notification that data is available, or unavailable, and it either shows the sales, or shows an error message.

The networking is handled by the framework. What data to fetch is determined by what type of subscription is created. All subscriptions extend RequestSubscription, and implement three methods:

1. isDataAvailable: returns YES if there is already data present from a previous network call, cache, etc. If this method returns yes, the framework won't make a network call, and it will change the subscription state to Available so that the controller that created the subscription get's notified that data is available
2. subscriptionMatches: returns YES if the passed subscription would ask for the same data as the current subscription. The framework keeps a queue of all pending subscriptions: if two subscriptions are waiting for the same data, and one get's a response, the other will get notified as well if this method returns YES.
3. apiRequest: returns an APIRequestController that has initiated a request. For SalesSubscription (used by HomeViewController), it's a simple, unauthenticated GET request.

All requests are created and initiated in APIRequestManager. To initiate a request, you call getFromURL, postToURL, or putToURL, with the appropriate url and parameters. The requestType parameter is what the APIRequestController uses to identify what type of request it was making when the request comes back: when requests come back, the framework figures out what to do with them in ModelContext -asyncRequest:didLoad:. This method sends the network result to the correct parser, and then updates the subscription state to success, unavailable, etc. This triggers subscriptionUpdatedState in whatever controller was the subscription's delegate, which, as previously discussed, is how the controller knows that the state of data has changed.

If you ever need to hook up additional requests, I recommend finding a similar one and following the subscription and its request through the framework, as outlined above.


Checkout Error Handling
-------

It is theoretically possible, depending on what errors the checkout API returns, to go *from* nearly any view in the checkout area *to* nearly any view in the checkout area. That's a lot of possibilities. Here's how we handled it.

In a controller that uses an API that can return checkout errors (ex StepTwoViewController returns an error about credit card cvv), if a checkout error occurs, present a popup with a button letting the user opt to go to the controller where they can fix the problem (in this example, CreditCardViewController). If the user clicks the button, the controller determines where to go to fix the error by asking the error for its XLCheckoutErrorResolution (in this case, XLCheckoutErrorResolutionCreditCard). (Note: If there are multiple errors, only fix the first one. The next attempt to use the checkout API will produce more errors if they are still relevant.). Then it calls [NavigationControlManager setErrorType: forViewController:], passing the XLCheckoutErrorResolution and itself. 

At this point, the NavigationControlManager takes over. Using the current controller and the intended destination (XLCheckoutErrorResolutionCreditCard -> CreditCardViewController), it goes through a series of switches to determine what kind of controller navigation needs to occur (here, the we are in step two, so the first step is to switch to step one). The NavigationControlManager gets notified when viewDidAppear get's called on any controller, so it is able to step in and completely control a series of navigations, one step at a time, to go from the controller that received the error to the controller that can handle the error. (So here, Step One's viewDidAppear would get called, and NavigationControlManager would determine that it needs to push CreditCardViewController. This was only a two step navigation, but they NavigationControlManager can handle more: consider DiscountViewController->StepTwoViewController->StepOneViewController->MyCartViewController). When the NavigationControlManager presents (or is about to present) the destination controller, it sets its XLCheckoutErrorResolution to XLCheckoutErrorResolutionNone, indicating that it is done hijacking control from the controllers: this way, when viewDidAppear is called on the destination controller, no more navigations will occur. (So, CreditCardViewController appears, and nothing happens: the user needs to make a change).

IMPORTANT: If any more pages are added to the checkout area, we will need to go through the switches in NavigationControlManager and make sure that the new page is integrated into the error handling.

Data-Driven Controllers (Highly interactive data-entry tables)
-------

In the settings and checkout areas, the PLNDR app contains many tables with rows performing independent navigation or data entry functions. From an implementation standpoint, this is very different than implementing a table like what is on the home or sale pages, where every row contains the same type of content. To display and interact with different types of rows, the cellForRowAtIndexPath, heightForRowAtIndexPath, and didSelectRowAtIndexPath methods need to be complex (because every row is different: translation: massive switch statements) and kept in sync (translation: duplication of massive switch statements. Yuck). This is a code-maintenance nightmare. Since this app is so heavy on controllers like this, we developed a framework to combat some of the big problems.

The idea is that everything a data-driven table cell needs to know about itself is contained in either the cell class (ex - how do I take information? Through a text box? Through a picker?) or a cell meta data class (ex - what is my title? What do I do when someone clicks my cell?). Every type of row (ex text entry on the left, text entry on the right, picker row, discloser row, etc) has a class extending BaseDataCell, and an associated cell meta data class extending CellMetaData. Every data-driven view controller extends BaseDataViewController (or BaseModalViewController, which extends BaseDataViewController), which handles all the hook-up to the framework. Then typically all a data-driven view controller need do is implement getCellMetaDataForIndexPath. This method will be a (long) switch statement which completely defines every cell in the table. Then the magic happens in the base class - cellForRowAtIndexPath and didSelectRowAtIndexPath call getCellMetaDataForIndexPath to determine how to take action, but you don't have to care in your view controller.

For a relatively clean example, take a look at the AddressViewController. For a slightly more complex example, look at StepOneViewController.

Note: if you need to add a new type of BaseDataCell and CellMetaData, use the existing classes as an example for how to write the delegate methods and implement them in BaseDataViewController.
